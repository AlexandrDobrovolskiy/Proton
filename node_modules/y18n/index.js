const fs = require('fs');
const path = require('path');
const util = require('util');

function Y18N(opts) {
  // configurable options.
  opts = opts || {};
  this.directory = opts.directory || './locales';
  this.updateFiles =
    typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;
  this.locale = opts.locale || 'en';
  this.fallbackToLanguage =
    typeof opts.fallbackToLanguage === 'boolean'
      ? opts.fallbackToLanguage
      : true;

  // internal stuff.
  this.cache = {};
  this.writeQueue = [];
}

Y18N.prototype.__ = function() {
  const args = Array.prototype.slice.call(arguments);
  const str = args.shift();
  let cb = function() {}; // start with noop.

  if (typeof args[args.length - 1] === 'function') cb = args.pop();
  cb = cb || function() {}; // noop.

  if (!this.cache[this.locale]) this._readLocaleFile();

  // we've observed a new string, update the language file.
  if (!this.cache[this.locale][str] && this.updateFiles) {
    this.cache[this.locale][str] = str;

    // include the current directory and locale,
    // since these values could change before the
    // write is performed.
    this._enqueueWrite([this.directory, this.locale, cb]);
  } else {
    cb();
  }

  return util.format(...[this.cache[this.locale][str] || str].concat(args));
};

Y18N.prototype._enqueueWrite = function(work) {
  this.writeQueue.push(work);
  if (this.writeQueue.length === 1) this._processWriteQueue();
};

Y18N.prototype._processWriteQueue = function() {
  const _this = this;
  const work = this.writeQueue[0];

  // destructure the enqueued work.
  const directory = work[0];
  const locale = work[1];
  const cb = work[2];

  const languageFile = this._resolveLocaleFile(directory, locale);
  const serializedLocale = JSON.stringify(this.cache[locale], null, 2);

  fs.writeFile(languageFile, serializedLocale, 'utf-8', err => {
    _this.writeQueue.shift();
    if (_this.writeQueue.length > 0) _this._processWriteQueue();
    cb(err);
  });
};

Y18N.prototype._readLocaleFile = function() {
  let localeLookup = {};
  const languageFile = this._resolveLocaleFile(this.directory, this.locale);

  try {
    localeLookup = JSON.parse(fs.readFileSync(languageFile, 'utf-8'));
  } catch (err) {
    if (err instanceof SyntaxError) {
      err.message = `syntax error in ${languageFile}`;
    }

    if (err.code === 'ENOENT') localeLookup = {};
    else throw err;
  }

  this.cache[this.locale] = localeLookup;
};

Y18N.prototype._resolveLocaleFile = function(directory, locale) {
  let file = path.resolve(directory, './', `${locale}.json`);
  if (
    this.fallbackToLanguage &&
    !this._fileExistsSync(file) &&
    ~locale.lastIndexOf('_')
  ) {
    // attempt fallback to language only
    const languageFile = path.resolve(
      directory,
      './',
      `${locale.split('_')[0]}.json`,
    );
    if (this._fileExistsSync(languageFile)) file = languageFile;
  }
  return file;
};

// this only exists because fs.existsSync() "will be deprecated"
// see https://nodejs.org/api/fs.html#fs_fs_existssync_path
Y18N.prototype._fileExistsSync = function(file) {
  try {
    return fs.statSync(file).isFile();
  } catch (err) {
    return false;
  }
};

Y18N.prototype.__n = function() {
  const args = Array.prototype.slice.call(arguments);
  const singular = args.shift();
  const plural = args.shift();
  const quantity = args.shift();

  let cb = function() {}; // start with noop.
  if (typeof args[args.length - 1] === 'function') cb = args.pop();

  if (!this.cache[this.locale]) this._readLocaleFile();

  let str = quantity === 1 ? singular : plural;
  if (this.cache[this.locale][singular]) {
    str = this.cache[this.locale][singular][quantity === 1 ? 'one' : 'other'];
  }

  // we've observed a new string, update the language file.
  if (!this.cache[this.locale][singular] && this.updateFiles) {
    this.cache[this.locale][singular] = {
      one: singular,
      other: plural,
    };

    // include the current directory and locale,
    // since these values could change before the
    // write is performed.
    this._enqueueWrite([this.directory, this.locale, cb]);
  } else {
    cb();
  }

  // if a %d placeholder is provided, add quantity
  // to the arguments expanded by util.format.
  const values = [str];
  if (~str.indexOf('%d')) values.push(quantity);

  return util.format(...values.concat(args));
};

Y18N.prototype.setLocale = function(locale) {
  this.locale = locale;
};

Y18N.prototype.getLocale = function() {
  return this.locale;
};

Y18N.prototype.updateLocale = function(obj) {
  if (!this.cache[this.locale]) this._readLocaleFile();

  for (const key in obj) {
    this.cache[this.locale][key] = obj[key];
  }
};

module.exports = function(opts) {
  const y18n = new Y18N(opts);

  // bind all functions to y18n, so that
  // they can be used in isolation.
  for (const key in y18n) {
    if (typeof y18n[key] === 'function') {
      y18n[key] = y18n[key].bind(y18n);
    }
  }

  return y18n;
};
